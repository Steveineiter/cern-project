# Generated by ChatGPT o1
#  TODO this means tests might be unstable / not correct. So if a test fails ponder if its your code or the test case.

from unittest.mock import patch, MagicMock

import pytest
from fastapi import HTTPException, status
from jose import JWTError

from src.authentication.router import (
    get_current_user,
    exchange_token,
    get_keycloak_public_key,
    SSO_BACKEND_ID,
)


@pytest.fixture
def valid_access_token():
    return "valid_access_token"


@pytest.fixture
def exchanged_access_token():
    return "exchanged_access_token"


@pytest.fixture
def jwks():
    return {
        "keys": [
            {
                "kty": "RSA",
                "kid": "key-id",
                "use": "sig",
                "n": "modulus",
                "e": "exponent",
            }
        ]
    }


@pytest.fixture
def payload():
    return {
        "cern_upn": "user@cern.ch",
        "email": "user@cern.ch",
        "given_name": "First",
        "family_name": "Last",
    }


@pytest.mark.asyncio
async def test_get_current_user_success(
    valid_access_token, exchanged_access_token, jwks, payload
):
    with patch(
        "src.authentication.router.exchange_token", return_value=exchanged_access_token
    ) as mock_exchange_token, patch(
        "src.authentication.router.get_keycloak_public_key", return_value=jwks
    ) as mock_get_jwks, patch(
        "src.authentication.router.jwt.decode", return_value=payload
    ) as mock_jwt_decode:

        result = await get_current_user(valid_access_token)
        assert result == {
            "cern_upn": payload["cern_upn"],
            "email": payload["email"],
            "given_name": payload["given_name"],
            "family_name": payload["family_name"],
        }
        mock_exchange_token.assert_called_once_with(valid_access_token)
        mock_get_jwks.assert_called_once()
        mock_jwt_decode.assert_called_once_with(
            exchanged_access_token,
            jwks,
            algorithms=["RS256"],
            audience=SSO_BACKEND_ID,
            issuer="https://auth.cern.ch/auth/realms/cern",
        )


@pytest.mark.asyncio
async def test_get_current_user_missing_cern_upn(
    valid_access_token, exchanged_access_token, jwks, payload
):
    payload_missing_cern_upn = payload.copy()
    del payload_missing_cern_upn["cern_upn"]

    with patch(
        "src.authentication.router.exchange_token", return_value=exchanged_access_token
    ), patch(
        "src.authentication.router.get_keycloak_public_key", return_value=jwks
    ), patch(
        "src.authentication.router.jwt.decode", return_value=payload_missing_cern_upn
    ):

        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(valid_access_token)
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
        assert exc_info.value.detail == "Could not validate user."


@pytest.mark.asyncio
async def test_get_current_user_jwt_error(
    valid_access_token, exchanged_access_token, jwks
):
    with patch(
        "src.authentication.router.exchange_token", return_value=exchanged_access_token
    ), patch(
        "src.authentication.router.get_keycloak_public_key", return_value=jwks
    ), patch(
        "src.authentication.router.jwt.decode", side_effect=JWTError
    ):

        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(valid_access_token)
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
        assert exc_info.value.detail == "Could not validate user."


def test_exchange_token_success():
    with patch("src.authentication.router.requests.post") as mock_post:
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"access_token": "exchanged_access_token"}
        mock_post.return_value = mock_response

        result = exchange_token("valid_access_token")
        assert result == "exchanged_access_token"
        mock_post.assert_called_once()
        # Optionally, add assertions to check the request data


def test_exchange_token_failure():
    with patch("src.authentication.router.requests.post") as mock_post:
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.text = "Error message"
        mock_post.return_value = mock_response

        with pytest.raises(Exception) as exc_info:
            exchange_token("invalid_access_token")
        assert str(exc_info.value) == "Token exchange failed: Error message"


def test_get_keycloak_public_key():
    with patch("src.authentication.router.requests.get") as mock_get:
        mock_response = MagicMock()
        mock_response.json.return_value = {"keys": ["key_data"]}
        mock_get.return_value = mock_response

        result = get_keycloak_public_key()
        assert result == {"keys": ["key_data"]}
        mock_get.assert_called_once_with(
            "https://auth.cern.ch/auth/realms/cern/protocol/openid-connect/certs"
        )
